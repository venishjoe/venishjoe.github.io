<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on VENISHJOE.NET</title>
    <link>https://venishjoe.net/categories/programming/index.xml</link>
    <description>Recent content in Programming on VENISHJOE.NET</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>venish@venishjoe.net (Venish Joe Clarence)</managingEditor>
    <webMaster>venish@venishjoe.net (Venish Joe Clarence)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="https://venishjoe.net/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java Bytecode Manipulation</title>
      <link>https://venishjoe.net/post/java-bytecode-manipulation/</link>
      <pubDate>Sun, 09 Apr 2017 01:40:22 -0500</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/java-bytecode-manipulation/</guid>
      <description>&lt;p&gt;In this article, I will show how to manipulate a compiled class file directly without decompiling it to java.&lt;/p&gt;

&lt;p&gt;I will be using &lt;a href=&#34;http://jboss-javassist.github.io/javassist/&#34;&gt;Javassist (Java Programming Assistant)&lt;/a&gt;, an external library for most of this tutorial.
&lt;a href=&#34;https://github.com/jboss-javassist/javassist/zipball/master&#34;&gt;Download&lt;/a&gt; latest JAR file to get examples work. I am using version &lt;em&gt;rel_3_22_0_cr1-4-g6a3ed31&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Every java file compiled will generate a class file which is a binary file containing Java bytecode which can be executed on any Java Virtual Machine.
Since the class files are generally not dependent on the platform they are compiled on, it makes Java applications platform independent.
In this article, we will explore how to statically analyze class files, modify them programmatically and execute.&lt;/p&gt;

&lt;h5 id=&#34;sample-class-for-bytecode-manipulation&#34;&gt;Sample Class for Bytecode Manipulation&lt;/h5&gt;

&lt;p&gt;We will start with a simple test class (ByteCodeEditorTest) which we will use to modify using Javassist. This class file will get an input from user and check if it matches
a predefined value within code and output message accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public String checkStatus(String _inputString){
    if (_inputString.equals(&#34;MAGIC&#34;))
        return &#34;Right!&#34;;
    return &#34;Wrong&#34;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once compiled, and executed below is a sample behaviour of the class. We will modify compiled class file directly to change its behaviour by modifying equality operator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ java ByteCodeEditorTest TEST
Wrong
$ java ByteCodeEditorTest MAGIC
Right!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start by looking at the compiled class file using javap. I have provided snippet of checkStatus() method from test class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;assembler&#34;&gt;$ javap -c ByteCodeEditorTest
Compiled from &#34;ByteCodeEditorTest.java&#34;
  public java.lang.String checkStatus(java.lang.String);
    Code:
       0: aload_1
       1: ldc           #7      // String MAGIC
       3: invokevirtual #8      // Method java/lang/String.equals:(Ljava/lang/Object;)Z
       6: ifeq          12
       9: ldc           #9      // String Right!
      11: areturn
      12: ldc           #10     // String Wrong
      14: areturn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The disassembled code contains mnemonic for Java bytecode instructions. We will be heavily using these as a part of bytecode manipulation.
Refer to &lt;a href=&#34;https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings&#34;&gt;Java bytecode instruction listings&lt;/a&gt; Wikipedia
article which contains all mnemonic and Opcode for Java bytecode.&lt;/p&gt;

&lt;p&gt;Interesting line is on index 6 from disassembled code which contains mnemonic ifeq which compares input string against built in value.
Let&amp;rsquo;s use Javassist to modify equality operator from ifeq to ifne.&lt;/p&gt;

&lt;h5 id=&#34;bytecode-manipulation-using-javassist&#34;&gt;Bytecode Manipulation using Javassist&lt;/h5&gt;

&lt;p&gt;Now that we have our test class and details on what has to be modified in bytecode, let&amp;rsquo;s create a new class file which loads compiled ByteCodeEditorTest class
for manipulation. With Javassist JAR in classpath, let&amp;rsquo;s load the test class file using javassist.CtClass.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;ClassPool _classPool = ClassPool.getDefault();
CtClass _ctClass = _classPool.makeClass(new FileInputStream(&#34;ByteCodeEditorTest.class&#34;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once ByteCodeEditorTest class is loaded, we will use javassist.CtMethod to extract all the methods from class and then use
javassist.bytecode.CodeAttribute &amp;amp; javassist.bytecode.CodeIterator to manipulate the class.&lt;/p&gt;

&lt;p&gt;CodeIterator allows us to traverse every bytecode instruction from class file and also provides methods to manipulate them. In our case,
from the javap output we know index 6 has to modified to change instruction set from ifeq to ifne. Looking at Opcode reference, hex value
for ifne is 9a. We will be using decimal format to update bytecode using CodeIterator.&lt;/p&gt;

&lt;p&gt;So we will be using CodeIterator.writeByte() method to update index 6 of ByteCodeEditorTest from exising value to 154 (9a converted to decimal).
Below table shows existing value (row1) and new value (row2)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Mnemonic&lt;/th&gt;
&lt;th&gt;Opcode (Hex)&lt;/th&gt;
&lt;th&gt;Opcode (Decimal)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ifeq&lt;/td&gt;
&lt;td&gt;0x99&lt;/td&gt;
&lt;td&gt;153&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ifne&lt;/td&gt;
&lt;td&gt;0x9a&lt;/td&gt;
&lt;td&gt;154&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;for(CtMethod _ctMethods:_ctClass.getDeclaredMethods()){
    CodeAttribute _codeAttribute = _ctMethods.getMethodInfo().getCodeAttribute();
    CodeIterator _codeIterator = _codeAttribute.iterator();
    while (_codeIterator.hasNext()) {
        int _indexOfCode = _codeIterator.next();
        int _valueOfIndex8Bit = _codeIterator.byteAt(_indexOfCode);
        //Checking index 6 and if Opcode is ifeq
        if(_valueOfIndex8Bit==153 &amp;&amp; _indexOfCode==6) {
            //Changing instruction from ifeq to ifne
            _codeIterator.writeByte(154, _indexOfCode);
        }
    }
}
//Write changes to class file
_ctClass.writeFile();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once this code is run, ByteCodeEditorTest class file will be modified with updated instructions.
When running javap on ByteCodeEditorTest now, it will produce below result of checkStatus() method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;assembler&#34;&gt;$ javap -c ByteCodeEditorTest
Compiled from &#34;ByteCodeEditorTest.java&#34;
  public java.lang.String checkStatus(java.lang.String);
    Code:
       0: aload_1
       1: ldc           #7      // String MAGIC
       3: invokevirtual #8      // Method java/lang/String.equals:(Ljava/lang/Object;)Z
       6: ifne          12
       9: ldc           #9      // String Right!
      11: areturn
      12: ldc           #10     // String Wrong
      14: areturn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, index 6 is now changed to ifne. Running ByteCodeEditorTest now will produce results which we were after.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ java ByteCodeEditorTest TEST
Right!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ByteCodeEditorTest class file was successfully modified to alter program flow without the need for re-compilation or decompilation.&lt;/p&gt;

&lt;p&gt;While this is a simple modification to a class file, we can do complex changes of adding new methods, classes, injecting code etc. using
Javassist library. I will cover complex scenarios in another article, but will give a high level overview of frequently used in
APIs in next section.&lt;/p&gt;

&lt;h5 id=&#34;other-javassist-apis&#34;&gt;Other Javassist APIs&lt;/h5&gt;

&lt;p&gt;While I covered bytecode manipulation, Javassist is a powerful library which can be used for complex changes. Highlighting some of those features here.&lt;/p&gt;

&lt;p&gt;javassist.CtMethod class can be used to inject new methods to existing class files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;//Defrosts so that the class can be modified
_ctClass.defrost();
CtMethod _ctMethod = CtNewMethod.make(&#34;public int newMethodFromJA() { return 1; }&#34;, _ctClass);
_ctClass.writeFile();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javassist.CtMethod class can also be used to inject code to existing class/methods using insertBefore(), insertAfter() and insertAt() methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;for(CtMethod method:_ctClass.getDeclaredMethods()){
    //Defrosts so that the class can be modified
    _ctClass.defrost();
    method.insertBefore(&#34;System.out.println(\&#34;Before every method call....\&#34;);&#34;);
    _ctClass.writeFile();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Javassist can also be used for static analysis of class files by displaying all method code (disassembled) of a class file or to display bytecode of a class file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;//Display Method Code
PrintStream _printStream = new PrintStream(System.out);
InstructionPrinter instructionPrinter = new InstructionPrinter(_printStream);
for(CtMethod method:_ctClass.getDeclaredMethods()){
    System.out.println(&#34;Method: &#34; + method.getName());
    instructionPrinter.print(method);
}
//Display Bytecode
for(CtMethod _ctMethods:_ctClass.getDeclaredMethods()){
    _ctClass.defrost();
    System.out.println(&#34;Method: &#34; +_ctMethods.getName());
    CodeAttribute _codeAttribute = _ctMethods.getMethodInfo().getCodeAttribute();
    CodeIterator _codeIterator = _codeAttribute.iterator();
    while (_codeIterator.hasNext()) {
        int _indexOfInstruction = _codeIterator.next();
        int _indexValue8Bit = _codeIterator.byteAt(_indexOfInstruction);
        System.out.println(Mnemonic.OPCODE[_indexValue8Bit]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Full source code for all snippets referenced in this article is available in &lt;a href=&#34;https://github.com/venishjoe/blog-code/tree/master/bytecode-manipulation&#34;&gt;my github&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dynamic Columns in JSP Model with Struts Framework</title>
      <link>https://venishjoe.net/post/dynamic-columns-in-jsp-model-with-struts/</link>
      <pubDate>Sun, 18 Apr 2010 21:41:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/dynamic-columns-in-jsp-model-with-struts/</guid>
      <description>&lt;p&gt;While developing web applications, we will come across a lot of scenarios where we should use dynamic columns depending on the entitlement of the user or
from the result set depending on the data itself. Dynamic columns in web applications give control to the user on what he wants to see
(specially when we have a huge amount of data to work with). For applications with sensitive data,
this can be even extended to act as a security layer where the access to specific data can be controlled with high precision.&lt;/p&gt;

&lt;p&gt;In this article, I will explain one of the methods to implement this in any J2EE application with little or no code change.&lt;/p&gt;

&lt;h5 id=&#34;high-level-architecture&#34;&gt;High Level Architecture&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00010/dynamic-columns-in-jsp-model-with-struts.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In a nut shell, this design uses the Application Context of the container to maintain the values pertaining to a particular user,
if the requirement demands not to maintain the preference after a user session is terminated, then it can be achieved by destroying the object stored in the context.&lt;/p&gt;

&lt;p&gt;We will start by creating a singleton class, which will be used to store the user preference about the columns.
The user preference object can be mapped  against the user id or any other primary key, so that different preferences are maintained for different users.
While the container starts, the instance for the singleton will be created. The default preferences can be loaded from a property / xml file or from a data store (DB).
This object will contain the preferences of different pages with the different key names so that the same object can be used to maintain the preference across the application.
This will be read during the logon operation and if the object in the application context doesn&amp;rsquo;t contain any values
(if the user logs in for the first time or in an application where the preference is specific to the session) then the default values are loaded. Once the page loads,
the preference can be read from the application context and can be  presented to the user. If the user edits his preferences, it will be updated in the application context.
Note that the application context is not persistent between container restarts, so appropriate mechanisms should be taken to store the data.&lt;/p&gt;

&lt;h5 id=&#34;implementation&#34;&gt;Implementation&lt;/h5&gt;

&lt;p&gt;Let’s go through the implementation now. The following steps describe how to integrate this component to an existing Struts application.&lt;/p&gt;

&lt;h6 id=&#34;start-up-servlet-and-initializing-the-singleton-class&#34;&gt;Start-up servlet and initializing the Singleton Class&lt;/h6&gt;

&lt;p&gt;Create an Initializer Servlet and make an entry for the same in the web.xml file so that the Servlet starts when the container is initialized.
Make sure the load-on-startup is set to 1, which ensures that the application server loads the servlet while startup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;xmls&#34;&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt; InitializerServlet &amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.startup.common.InitializerServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;load-on-startup&amp;gt; 1 &amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, create a Singleton class, which contains getter and setter methods for dynamic column preference, the object can be any collection,
we are using Hash Map in this example which will be used to store the primary key against the list containing the preference.
The set &amp;amp; get methods in the Singleton should be synchronized so that the simultaneous access is restricted. Also override the clone() method in your singleton.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class AppSingleton implements Serializable {
    private Hashtable cusomizeViewValues = null;
    private static AppSingleton appSingleton = null;

    private AppSingleton (){ }

    public synchronized void setCusomizeViewValues (Hashtable cusomizeViewValues){
        this.cusomizeViewValues = cusomizeViewValues;
    }

    public static synchronized AppSingleton getInstance () throws Exception {
        try {
            if (appSingleton == null)
                return new AppSingleton ();
          } catch (Exception e) {
            throw new Exception();
        }
    }

    public Object clone() throws CloneNotSupportedException{
        throw new CloneNotSupportedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the startup servlet, create an instance of the singleton class. When created, the object will be available in the application context of the container,
and no one will be able to create another instance, until the object created in startup is destroyed.
Since we have overridden the clone method, no one will be able to clone the particular object.
These measures are to ensure the integrity of the user preference stored in the singleton.
A sample Initializer servlet will look like the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class InitializerServlet extends HttpServlet {
    public void init () throws ServletException {
        AppSingleton appSingleton = AppSingleton.getInstance ();
    }

    public void destroy (){}
    public void service (HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, create a Data Transfer Object (DTO) / Value Object (VO) for storing the values.
The VO/DTO will contain just two getters and setters, one for the Column Display name and the other for the bean property. This will be a POJO.&lt;/p&gt;

&lt;h6 id=&#34;populate-the-application-context&#34;&gt;Populate the Application context&lt;/h6&gt;

&lt;p&gt;When the container starts, populate the list in the application context, from the property file or from the data source.
If you are having a separate page to choose the columns displayed, you can use the same list to render the values initially.
Similarly if the user has changed his preference then update the application context accordingly.
This can be done during the Login Action, once the user is authorized and authenticated.
You can use your own logic to get all the user preference and then update list with DTO’s/VO’s containing the display name and the property name.
This list is updated in the application context against the primary key.
Before updating the application context check if the PK is already present in the Hash Table if yes, update or create a new entry.&lt;/p&gt;

&lt;p&gt;A sample property file will look like the one given below. By using different keys, we can have entries for different pages.
Also the columns to be displayed to the user irrespective of the individual preference can also be marked here under a different key.
The columns users are not allowed to modify are added to the rendering list once the request is got from the particular page and not during the logon time.
The values are appended to the modifiable columns list and rendered to the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;properties&#34;&gt;Validations$Optional=Plan #, Plan Name, Administrator
Validations$Core= Plan Val Description, Plan Val Status

# Optional represents the Columns users can modify
# Core represents the Columns users can’t modify

Validations$Plan#=strClientExtEntityId
Validations$PlanName=strPlanName
Validations$Administrator=strAdministrator
Validations$PlanValDescription=strDescription
Validations$PlanValStatus=strStatus
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;rendering-logic&#34;&gt;Rendering Logic&lt;/h6&gt;

&lt;p&gt;Once the values are available in the session, using JSP, logic iterate, render the Column names.
Then to display the values from the result set, use the logic iterate with the list containing the values for the page,
which is used to render the &amp;lt;tr&amp;gt; tag and inside that logic iterate, use another logic iterate,
which is used to render the columns and use a bean define tag to get the column name properties in a scriplet variable and then use a bean define tag to display the value of the property.
This logic is highly dynamic.&lt;/p&gt;

&lt;p&gt;To display the column names,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;jsp&#34;&gt;&amp;lt;logic:iterate name=&#34;&amp;lt;Form Bean Name&amp;gt;&#34; id=&#34;testId&#34; property=&#34;&amp;lt;Name of the List&amp;gt;&#34; &amp;gt;
    &amp;lt;td&amp;gt;
        &amp;lt;bean:write name=&#34; testId &#34; property=&#34;&amp;lt;Col Disp Name&amp;gt;&#34;/&amp;gt;
    &amp;lt;/td&amp;gt;
&amp;lt;/logic:iterate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To display the result set,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;jsp&#34;&gt;&amp;lt;logic:iterate name=&#34;&amp;lt;Form Name&amp;gt;&#34; id=&#34;outerId&#34; property=&#34;&amp;lt;Property of the Hitlist&amp;gt;&#34;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;logic:iterate name=&#34;&amp;lt;Form Name&amp;gt;&#34; id=&#34;innerId&#34; property=&#34;&amp;lt;Name of the List&amp;gt;&#34; &amp;gt;
        &amp;lt;bean:define name=&#34;innerId&#34; id=&#34;propId&#34; property=&#34;&amp;lt;Col Property&amp;gt;&#34; type=&#34;String&#34;/&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;bean:write name=&#34;outerId&#34; property=&#34;&amp;lt;%= propId %&amp;gt;&#34; /&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/logic:iterate&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/logic:iterate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also will have situations to display hyperlinks, textboxes etc. in the result set, the same logic can be used to display the different objects in the JSP.
Just before the bean write tag, have a logic equal tag to check for specific types and render the display.&lt;/p&gt;

&lt;p&gt;This architecture is highly customizable and can be easily plugged in into any existing J2EE application. Also this can be easily enhanced to incorporate new functionalities.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java String Concatenation and Performance</title>
      <link>https://venishjoe.net/post/java-string-concatenation-and-performance/</link>
      <pubDate>Sun, 08 Nov 2009 18:01:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/java-string-concatenation-and-performance/</guid>
      <description>&lt;p&gt;The quick and dirty way to concatenate strings in Java is to use the concatenation operator (+).
This will yield a reasonable performance if you need to combine two or three strings (fixed-size).
But if you want to concatenate n strings in a loop, the performance degrades in multiples of n.
Given that String is immutable, for large number of string concatenation operations, using (+) will give us a worst performance.
But how bad ? How StringBuffer, StringBuilder or String.concat() performs if we put them on a performance test ?.
This article will try to answer those questions.&lt;/p&gt;

&lt;p&gt;We will be using &lt;a href=&#34;https://github.com/perf4j/perf4j&#34;&gt;Perf4J&lt;/a&gt; to calculate the performance, since this library will give us aggregated performance statistics
like mean, minimum, maximum, standard deviation over a set time span. In the code, we will concatenate a string (*)
repeatedly 50,000 times and this iteration will be performed 21 times so that we can get a good standard deviation.
The following methods will be used to concatenate strings.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concatenation Operator (+)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#concat%28java.lang.String%29&#34;&gt;String concat method&lt;/a&gt; - concat(String str)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/j2se/1.4.2/docs/api/java/lang/StringBuffer.html#append%28java.lang.String%29&#34;&gt;StringBuffer append method&lt;/a&gt; - append(String str)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuilder.html#append%28java.lang.String%29&#34;&gt;StringBuilder append method&lt;/a&gt; - append(String str)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And finally we will look at the byte code to see how each of these operations perform. Let’s start building the class.
Note that each of the block in the code should be wrapped around the Perf4J library to calculate the performance in each iteration.
Let’s define the outer and inner iterations first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;private static final int OUTER_ITERATION=20;
private static final int INNER_ITERATION=50000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s implement each of the four methods mentioned in the article.
Nothing fancy here, plain implementations of (+), String.concat(), StringBuffer.append() &amp;amp; StringBuilder.append().&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String addTestStr = &#34;&#34;;
String concatTestStr = &#34;&#34;;
StringBuffer concatTestSb = null;
StringBuilder concatTestSbu = null;

for (int outerIndex=0;outerIndex&amp;lt;=OUTER_ITERATION;outerIndex++) {
    StopWatch stopWatch = new LoggingStopWatch(&#34;StringAddConcat&#34;);
    addTestStr = &#34;&#34;;
    for (int innerIndex=0;innerIndex&amp;lt;=INNER_ITERATION;innerIndex++)
        addTestStr += &#34;*&#34;;
    stopWatch.stop();
}

for (int outerIndex=0;outerIndex&amp;lt;=OUTER_ITERATION;outerIndex++) {
    StopWatch stopWatch = new LoggingStopWatch(&#34;StringConcat&#34;);
    concatTestStr = &#34;&#34;;
    for (int innerIndex=0;innerIndex&amp;lt;=INNER_ITERATION;innerIndex++)
        concatTestStr = concatTestStr.concat(&#34;*&#34;);
    stopWatch.stop();
}

for (int outerIndex=0;outerIndex&amp;lt;=OUTER_ITERATION;outerIndex++) {
    StopWatch stopWatch = new LoggingStopWatch(&#34;StringBufferConcat&#34;);
    concatTestSb = new StringBuffer();
    for (int innerIndex=0;innerIndex&amp;lt;=INNER_ITERATION;innerIndex++)
        concatTestSb.append(&#34;*&#34;);
    stopWatch.stop();
}

for (int outerIndex=0;outerIndex&amp;lt;=OUTER_ITERATION;outerIndex++) {
    StopWatch stopWatch = new LoggingStopWatch(&#34;StringBuilderConcat&#34;);
    concatTestSbu = new StringBuilder();
    for (int innerIndex=0;innerIndex&amp;lt;=INNER_ITERATION;innerIndex++)
        concatTestSbu.append(&#34;*&#34;);
    stopWatch.stop();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s run this program and generate the performance metrics. I ran this program in a 64-bit OS (Windows 7), 32-bit JVM (7-ea), Core 2 Quad CPU (2.00 GHz) with 4 GB RAM.&lt;/p&gt;

&lt;p&gt;The output from the 21 iterations of the program is plotted below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00009/java-string-concatenation-and-performance.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Well, the results are pretty conclusive and as expected. One interesting point to notice is how better String.concat performs.
We all know String is immutable, then how the performance of concat is better. To answer the question we should look at the byte code.
I have included the whole byte code in the download package, but let’s have a look at the below snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bytecode&#34;&gt;45: new #7; //class java/lang/StringBuilder
48: dup
49: invokespecial #8; //Method java/lang/StringBuilder.&#34;&amp;lt;init&amp;gt;&#34;:()V
52: aload_1
53: invokevirtual #9; //Method java/lang/StringBuilder.append:
    (Ljava/lang/String;)Ljava/lang/StringBuilder;
56: ldc #10; //String *
58: invokevirtual #9; //Method java/lang/StringBuilder.append:
    (Ljava/lang/String;)Ljava/lang/StringBuilder;
61: invokevirtual #11; //Method java/lang/StringBuilder.toString:()
    Ljava/lang/String;
64: astore_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the byte code for String.concat(), and its clear from this that the String.concat is using StringBuilder for concatenation and the performance should be as good as String Builder.
But given that the source object being used is String, we do have some performance loss in String.concat.&lt;/p&gt;

&lt;p&gt;So for the simple operations we should use String.concat compared to (+), if we don’t want to create a new instance of StringBuffer/Builder.
But for huge operations, we shouldn’t be using the concat operator, as seen in the performance results it will bring down the application to its knees and spike up the CPU utilization.
To have the best performance, the clear choice is StringBuilder as long as you do not need thread-safety or synchronization.&lt;/p&gt;

&lt;p&gt;Full source of this application is available in &lt;a href=&#34;https://github.com/venishjoe/blog-code/tree/master/string-concatenation-perf&#34;&gt;my github&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recursive File Tree Traversing in Java using NIO.2</title>
      <link>https://venishjoe.net/post/recursive-file-tree-traversing-in-java-using-nio/</link>
      <pubDate>Mon, 26 Oct 2009 11:45:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/recursive-file-tree-traversing-in-java-using-nio/</guid>
      <description>&lt;p&gt;In my &lt;a href=&#34;https://venishjoe.net/post/monitor-a-directory-for-changes-using-java/&#34;&gt;previous article about NIO.2&lt;/a&gt;,
we have seen how to implement a service which monitors a directory recursively for any changes.
In this article we will look at another improvement in JDK7 (NIO.2) called FileWatcher.
This will allow us to implement a search or index. For example, we can find all the $some_pattern$ files in a given directory recursively and (or)
delete / copy all the all the $some_pattern$ files in a file system.
In a nutshell FileWatcher will get us a list of files from a file system based on a pattern which can be processed based on our requirement.&lt;/p&gt;

&lt;p&gt;The FileVistor is an interface and our class should implement it.
We have two methods before the traversal starts at the directory level &amp;amp; file level, and one method after the traversal is complete,
which can be used for clean up or post processing. The important points from the interface is given in the below diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00008/recursive-file-tree-traversing-class-diagram.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;While I think FileVistor is the best way to handle this, JDK7 NIO.2 has given another option to achieve the same, a class named SimpleFileVistor (which implements FileVisitor).
It should be self explanatory, a simplified version of FileVisitor.
We can extend the SimpileFileVisitor into our class and then traverse the directory with overriding only the methods we need, and if any step fails we will get an IOException.&lt;/p&gt;

&lt;p&gt;According to me, FileVisitor is better because it forces you to implement the methods (sure, you can leave them blank)
since these methods are really important if you plan to implement recursive delete / copy or work with symbolic links.
For example, if you are copying some files to a directory you should make sure that the directory should be created
first before copying which can be done in the preVisitDirectory().&lt;/p&gt;

&lt;p&gt;The other area of concern is symbolic links and how this will be handled by FileVisitor. This can be achieved using FileVisitOption enums.
By default, the symbolic links are not followed so that we are not accidentally deleting any directories in a recursive delete.
If you want to handle manually, there are two options FOLLOW_LINKS (follow the links) &amp;amp; DETECT_CYCLES (catch circular references).&lt;/p&gt;

&lt;p&gt;If you want to exclude some directory from FileVisitor or if you are looking for a directory or a file in the file system and once you find it
you want to stop searching that can be implemented by using the return type of FileVisitor, called FileVisitResult.
SKIP_SUBTREE allows us to skip directories &amp;amp; subdirectories. TERMINATE stops the traversing.&lt;/p&gt;

&lt;p&gt;The search can be initiated by the walkFileTree() method in Files class. This will take the starting directory (or root directory in your search) as a parameter.
You can also define Integer.MAX_VALUE if you want to manually specify the depth.
And as mentioned in the above diagram, define FileVisitOption for symbolic links if needed.&lt;/p&gt;

&lt;p&gt;Enough with the API description, let&amp;rsquo;s write some sample code to implement what we discussed.
We will be using the SimpleFileVisitor so that in our demo we don’t need to implement all the methods.&lt;/p&gt;

&lt;p&gt;Let’s start with defining the pattern which needs to be searched for. In this example,
we will search for all the *txt file / directory names recursively in any given directory.
This can be done with getPathMatcher() in FileSystems&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(&#34;glob:&#34; + &#34;*txt*&#34;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s initiate the search by calling walkFileTree() as mentioned below. We are not defining anything specific for symbolic links so, by default its NO_FOLLOW.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Files.walkFileTree(Paths.get(&#34;D://Search&#34;), fileVisitor);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s go through the implementations of class SimpleFileVisitor, we will be overriding only visitFile() &amp;amp; preVisitDirectory() in this example,
but its a good practice to override all the five methods so that we have more control over the search. The implementation is pretty simple,
based on the pattern the below methods will search for a directory or file and print the path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Override
public FileVisitResult visitFile(Path filePath, BasicFileAttributes basicFileAttributes) {
    if (filePath.getName() != null &amp;amp;&amp;amp; pathMatcher.matches(filePath.getName()))
        System.out.println(&#34;FILE: &#34; + filePath);
    return FileVisitResult.CONTINUE;
}

@Override
public FileVisitResult preVisitDirectory(Path directoryPath) {
    if (directoryPath.getName() != null &amp;amp;&amp;amp; pathMatcher.matches(directoryPath.getName()))
        System.out.println(&#34;DIR: &#34; + directoryPath);
    return FileVisitResult.CONTINUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once this is completed, we can use the postVisitDirectory() to perform additional tasks or any cleanup if needed. A sample output from my machine is given below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00008/recursive-file-tree-traversing-output.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The complete source code is given below. Please note that you need JDK7 to run this code.
Source is also available in &lt;a href=&#34;https://github.com/venishjoe/blog-code/tree/master/jsr203-nio2_file-visitor&#34;&gt;my github&lt;/a&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class NIO2_FileVisitor extends SimpleFileVisitor&amp;lt;Path&amp;gt; {
    private PathMatcher pathMatcher;

    @Override
    public FileVisitResult visitFile(Path filePath, BasicFileAttributes basicFileAttributes) {
        if (filePath.getName() != null &amp;amp;&amp;amp; pathMatcher.matches(filePath.getName()))
                System.out.println(&#34;FILE: &#34; + filePath);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult preVisitDirectory(Path directoryPath) {
        if (directoryPath.getName() != null &amp;amp;&amp;amp; pathMatcher.matches(directoryPath.getName()))
                System.out.println(&#34;DIR: &#34; + directoryPath);
        return FileVisitResult.CONTINUE;
    }

    public static void main(String[] args) throws IOException {
        NIO2_FileVisitor fileVisitor = new NIO2_FileVisitor();
        fileVisitor.pathMatcher = FileSystems.getDefault().getPathMatcher(&#34;glob:&#34; + &#34;*txt*&#34;);
        Files.walkFileTree(Paths.get(&#34;D://Search&#34;), fileVisitor);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dynamically Load Compiled Java Class as a Byte Array and Execute</title>
      <link>https://venishjoe.net/post/dynamically-load-compiled-java-class/</link>
      <pubDate>Wed, 21 Oct 2009 21:20:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/dynamically-load-compiled-java-class/</guid>
      <description>&lt;p&gt;As we know, all the compiled java classes runs inside the JVM. The default class loader from Sun loads the classes into JVM and executes it.
This class loader is a part of JVM which loads the compiled byte code to memory. In this article,
I will show how to convert a compiled java class to a array of bytes and then load these array of bytes into another class
(which can be over the network) and execute the array of bytes.&lt;/p&gt;

&lt;p&gt;So the question arises, why should we write a custom class loader ? There are some distinct advantages. Some of them below&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We can load a class over any network protocol. Since the java class can be converted to a series of numbers (array of bytes), we can use most of the protocols.&lt;/li&gt;
&lt;li&gt;Load Dynamic classes based on the type of user, especially useful when you want to validate the license of your software over the web and if you are paranoid about the security.&lt;/li&gt;
&lt;li&gt;More flexible and secure, you can encrypt the byte stream (asymmetric or symmetric) ensuring safer delivery.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this article we will be creating three classes&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;JavaClassLoader – The custom class loader which will load the array of bytes and execute. In other words, the client program.&lt;/li&gt;
&lt;li&gt;Class2Byte – The Java class which converts any compiled class / object to a array of bytes&lt;/li&gt;
&lt;li&gt;ClassLoaderInput – The class which will be converted to array of bytes and transferred&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s divide this article into two sections, in the fist section we will convert the java class to array of bytes and in the second section, we will load that array.&lt;/p&gt;

&lt;h5 id=&#34;create-convert-the-java-class-to-array-of-bytes&#34;&gt;Create &amp;amp; Convert the Java class to array of bytes&lt;/h5&gt;

&lt;p&gt;Let’s write a simple class (ClassLoaderInput) which just prints a line. This is the class which will be converted to a byte array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class ClassLoaderInput {
    public void printString() {
        System.out.println(&#34;Hello World!&#34;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s write another class (Class2Byte) which will convert the ClassLoaderInput to a byte of array.
The concept to convert the file is simple, compile the above file and load the class file through input stream and with an offset
read and convert the class to bytes and write the output in to another out stream.
We need these bytes as a comma separated value, so we will use StringBuffer to add comma between the bytes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;int _offset=0;
int _read=0;

File fileName = new File(args [0]);
InputStream fileInputStream = new FileInputStream(fileName);
FileOutputStream fileOutputStream = new FileOutputStream(args[1]);
PrintStream printStream = new PrintStream(fileOutputStream);
StringBuffer bytesStringBuffer = new StringBuffer();

byte[] byteArray = new byte[(int)fileName.length()];
while (_offset &amp;lt; byteArray.length &amp;amp;&amp;amp;
    (_read=fileInputStream.read(byteArray, _offset,
    byteArray.length-_offset)) &amp;gt;= 0)
        _offset += _read;

fileInputStream.close();
for (int index = 0; index &amp;lt; byteArray.length; index++)
    bytesStringBuffer.append(byteArray[index]+&#34;,&#34;);

printStream.print(bytesStringBuffer.length()==0 ? &#34;&#34; :
    bytesStringBuffer.substring(0, bytesStringBuffer.length()-1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s run this file and generate the output. A sample output from my machine is below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00007/dynamically-load-compiled-java-class-output.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now,we have the sample class (ClassLoaderInput) file as a bunch of numbers. Now this bunch of numbers can be transferred over any protocol to our
custom class loader which will “reconstruct” the class from these bytes and run it,
without any physical trace in the client machine (the array of bytes will be on memory).&lt;/p&gt;

&lt;h5 id=&#34;load-the-array-of-bytes-and-execute&#34;&gt;Load the array of bytes and execute&lt;/h5&gt;

&lt;p&gt;Now, to the important part of this article, we are going to write a custom class loader which will load those bunch of numbers (array) and execute them.
The array of bytes can be transferred over the network but in this example, we will define it as a string in the class loader for demonstration purpose.&lt;/p&gt;

&lt;p&gt;Let’s start by defining the array of bytes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;private int[] data = {-54,-2,-70,-66,0,0,0,51,0,31,10,0,6,0,17,9,0,18,0,19,8,
    0,20,10,0,21,0,22,7,0,23,7,0,24,1,0,6,60,105,110,105,116,62,1,0,3,40,41,86,1,
    0,4,67,111,100,101,1,0,15,76,105,110,101,78,117,109,98,101,114,84,97,98,108,
    101,1,0,18,76,111,99,97,108,86,97,114,105,97,98,108,101,84,97,98,108,101,1,0,
    4,116,104,105,115,1,0,18,76,67,108,97,115,115,76,111,97,100,101,114,73,110,
    112,117,116,59,1,0,11,112,114,105,110,116,83,116,114,105,110,103,1,0,10,83,
    111,117,114,99,101,70,105,108,101,1,0,21,67,108,97,115,115,76,111,97,100,101,
    114,73,110,112,117,116,46,106,97,118,97,12,0,7,0,8,7,0,25,12,0,26,0,27,1,0,
    12,72,101,108,108,111,32,87,111,114,108,100,33,7,0,28,12,0,29,0,30,1,0,16,67,
    108,97,115,115,76,111,97,100,101,114,73,110,112,117,116,1,0,16,106,97,118,97,
    47,108,97,110,103,47,79,98,106,101,99,116,1,0,16,106,97,118,97,47,108,97,110,
    103,47,83,121,115,116,101,109,1,0,3,111,117,116,1,0,21,76,106,97,118,97,47,105,
    111,47,80,114,105,110,116,83,116,114,101,97,109,59,1,0,19,106,97,118,97,47,105,
    111,47,80,114,105,110,116,83,116,114,101,97,109,1,0,7,112,114,105,110,116,108,
    110,1,0,21,40,76,106,97,118,97,47,108,97,110,103,47,83,116,114,105,110,103,59,
    41,86,0,33,0,5,0,6,0,0,0,0,0,2,0,1,0,7,0,8,0,1,0,9,0,0,0,47,0,1,0,1,0,0,0,5,42,
    -73,0,1,-79,0,0,0,2,0,10,0,0,0,6,0,1,0,0,0,1,0,11,0,0,0,12,0,1,0,0,0,5,0,12,0,
    13,0,0,0,1,0,14,0,8,0,1,0,9,0,0,0,55,0,2,0,1,0,0,0,9,-78,0,2,18,3,-74,0,4,-79,
    0,0,0,2,0,10,0,0,0,10,0,2,0,0,0,3,0,8,0,4,0,11,0,0,0,12,0,1,0,0,0,9,0,12,0,13,
    0,0,0,1,0,15,0,0,0,2,0,16};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The conversion of these bytes to class is done by the &lt;a href=&#34;http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassLoader.html#defineClass%28byte[],%20int,%20int%29&#34;&gt;ClassLoader.defineClass()&lt;/a&gt;
method We should supply the stream of bytes that make up the class data.
The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the &lt;a href=&#34;http://java.sun.com/docs/books/vmspec/&#34;&gt;Java Virtual Machine Specification&lt;/a&gt;.
The offset and length will be the additional parameters. Once the defineClass converts the array to class,
then we can use reflection to execute the methods in the class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;JavaClassLoader _classLoader = new JavaClassLoader();
byte[] rawBytes = new byte[_classLoader.data.length];
for (int index = 0; index &amp;lt; rawBytes.length; index++)
    rawBytes[index] = (byte) _classLoader.data[index];
Class regeneratedClass = _classLoader.defineClass(args[0],
    rawBytes, 0, rawBytes.length);
regeneratedClass.getMethod(args[1], null).invoke(null, new Object[] { args });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s compile the class loader and run. The the class file name &amp;amp; method name should be passed as a run time argument.
If you have done everything right, you should see the output from the input class which we created (ClassLoaderInput) initially.
Sample output from my machine below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00007/dynamically-load-compiled-java-class-output-patched.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Full source of this application is available in &lt;a href=&#34;https://github.com/venishjoe/blog-code/tree/master/dynamic-byte-class-array&#34;&gt;my github&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Monitor a Directory for Changes using Java</title>
      <link>https://venishjoe.net/post/monitor-a-directory-for-changes-using-java/</link>
      <pubDate>Sun, 18 Oct 2009 02:23:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/monitor-a-directory-for-changes-using-java/</guid>
      <description>&lt;p&gt;Many applications which we use on a day to day basis like a music organizer, file editors monitor the directory for any changes in the files/directories and
take appropriate action in the application if there are any changes detected on the fly.
Since Java do not have direct access to the system level calls (unless we use JNI, which will make the code platform specific)
the only way to monitor any directory is to use a separate thread which will be using a lot of resources (memory &amp;amp; disk I/O) to monitor the changes inside the directory.
If we have sub-directories and need a recursive monitor, then the thread becomes more resource intensive.&lt;/p&gt;

&lt;p&gt;There was a JSR (Java Specification Request) requested to add / rewrite more I/O APIs for Java platform. This was implemented in JDK 7 as
&lt;a href=&#34;http://jcp.org/en/jsr/detail?id=203&#34;&gt;JSR 203&lt;/a&gt; with support for APIs like file system access, scalable asynchronous I/O operations,
socket-channel binding and configuration, and multicast datagrams.&lt;/p&gt;

&lt;p&gt;JSR 203 is one of the big feature for JDK 7 (Developer Preview is available in java.sun.com) and its been implemented as the second I/O package is java,
called as NIO.2. I will be looking into more of these packages in future posts, but in this,
I will show how to monitor a directory and its sub-directories for any changes using NIO.2 (JDK 7).&lt;/p&gt;

&lt;p&gt;The APIs which we will be using &lt;a href=&#34;http://java.sun.com/javase/7/docs/api/java/nio/file/WatchService.html&#34;&gt;WatchService&lt;/a&gt;
(a watch service that watches registered objects for changes and events), &lt;a href=&#34;http://java.sun.com/javase/7/docs/api/java/nio/file/WatchKey.html&#34;&gt;WatchKey&lt;/a&gt;
(a token representing the registration of a watchable object with a WatchService) and &lt;a href=&#34;http://java.sun.com/javase/7/docs/api/java/nio/file/WatchEvent.html&#34;&gt;WatchEvent&lt;/a&gt;
(an event or a repeated event for an object that is registered with a WatchService) to monitor a directory. So, without further explanation, let’s start working on the code.&lt;/p&gt;

&lt;p&gt;Please note that you need JDK 7 to run this program. While writing this post,
JDK 7 is available as a EA (Early Access) in &lt;a href=&#34;http://java.sun.com/javase/downloads/ea.jsp&#34;&gt;Java Early Access Downloads&lt;/a&gt; page. Download the JDK and install it.&lt;/p&gt;

&lt;p&gt;The first step is to get a directory to monitor. Path is one of the new I/O API as a part of NIO.2 which gives us more control over the I/O.
So let’s get the directory to watch, if you want to watch the directory recursively then there should be another boolean flag defined,
but in this example we will watch only the parent directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Path _directotyToWatch = Paths.get(args[0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s create a Watch service to the above directory and add a key to the service.
In the watch key we can define what are all the events we need to look for.
In this example we will monitor Create, Delete &amp;amp; Rename/Modify of the files or directories in the path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;WatchService watcherSvc = FileSystems.getDefault().newWatchService();
WatchKey watchKey = _directotyToWatch.register(
    watcherSvc,ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the variables defined. Let’s start a infinite loop to monitor the directory for any changes using WatchEvent.
We will poll events in the directory and once some event is triggered (based on the WatchKey definition)
we will print the type of event occurred and the name of the file/directory on which the event occurred. Once done, we will reset the watch key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;while (true) {
    watchKey=watcherSvc.take();
    for (WatchEvent&amp;lt;?&amp;gt; event: watchKey.pollEvents()) {
        WatchEvent&amp;lt;Path&amp;gt; watchEvent = castEvent(event);
        System.out.println(event.kind().name().toString() + &#34; &#34;
            + _directotyToWatch.resolve(watchEvent.context()));
    watchKey.reset();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to make the WatchEvent &amp;lt;Path&amp;gt; work, we should create a small utility as below ( this is the castEvent which is used in the above code).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;static &amp;lt;T&amp;gt; WatchEvent&amp;lt;T&amp;gt; castEvent(WatchEvent&amp;lt;?&amp;gt; event) {
    return (WatchEvent&amp;lt;T&amp;gt;)event;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now compile the file and give a directory as a runtime parameter while running it.
Once the program starts running, start creating some directories/files or modify/rename some files in the directory which you gave as a parameter,
the program will start triggering the event and you should be able to watch the modifications in the console.
A sample output from my machine is below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00006/monitor-a-directory-output.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Full source of this application is available in &lt;a href=&#34;https://github.com/venishjoe/blog-code/tree/master/jsr203-nio2-watch-folder&#34;&gt;my github&lt;/a&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;import java.nio.file.*;
import static java.nio.file.StandardWatchEventKind.*;

static &amp;lt;T&amp;gt; WatchEvent&amp;lt;T&amp;gt; castEvent(WatchEvent&amp;lt;?&amp;gt; event) {
    return (WatchEvent&amp;lt;T&amp;gt;)event;
}

public static void main (String args[]) throws Exception {
    Path _directotyToWatch = Paths.get(args[0]);
    WatchService watcherSvc = FileSystems.getDefault().newWatchService();
    WatchKey watchKey = _directotyToWatch.register(watcherSvc,
        ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);

    while (true) {
        watchKey=watcherSvc.take();
        for (WatchEvent&amp;lt;?&amp;gt; event: watchKey.pollEvents()) {
            WatchEvent&amp;lt;Path&amp;gt; watchEvent = castEvent(event);
            System.out.println(event.kind().name().toString() + &#34; &#34;
                + _directotyToWatch.resolve(watchEvent.context()));
            watchKey.reset();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Signing Java Objects for Secure Transfer</title>
      <link>https://venishjoe.net/post/signing-java-objects-for-secure-transfer/</link>
      <pubDate>Tue, 13 Oct 2009 22:45:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/signing-java-objects-for-secure-transfer/</guid>
      <description>&lt;p&gt;In distributed J2EE applications or in any application where you need to transfer Java objects to another system then there is always a security risk where the
object can be intercepted which can result in data theft/loss. Especially in Serialization, (where the object is a physical file in the native file system)
when the serialized Java objects are sent through the network, whoever knows the type of the object can always read it.&lt;/p&gt;

&lt;p&gt;In this article, we will build two simple applications, one which generates the object, the keys (public &amp;amp; private) and signs the object with the private key.
Other application which verifies the signed object in other end over the network or another application in the same machine. Both these apps can run independently in different machines.
For signing the object we will be using Public-Key cryptography. This is one of the most widely used standards to sign data along with DSA &amp;amp; SHA1PRNG
(cryptographically strong pseudo-random number generator (PRNG)).
Public-Key cryptography is a asymmetric key algorithm, where the key used to encrypt a message is not the same as the key used to decrypt it.&lt;/p&gt;

&lt;p&gt;This is the class diagram of the applications which we will be building. This article will be divided into two parts, the first part we will sign the object (serialized)
and in the second part, we will verify it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00005/signing-java-objects-class-layout.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;sign-the-java-object&#34;&gt;Sign the Java Object&lt;/h5&gt;

&lt;p&gt;First of all we need a class which will generate a public and private key.
We will create a class named SecurityUtil which will generate those based on DSA (we can use RSA or any other algorithm as long as its available)
and we will generate a cryptographically strong pseudo-random number generator (PRNG) which can be clubbed along with DSA (SHA1PRNG).
The strength of the key will be 1024.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;protected KeyPair generateKey () throws Exception {
    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&#34;DSA&#34;);
    SecureRandom secureRandom = SecureRandom.getInstance(&#34;SHA1PRNG&#34;);
    keyPairGen.initialize(1024,secureRandom);
    KeyPair keyPair = keyPairGen.generateKeyPair();
    return keyPair;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we will create a class named EmployeeValueObject which is nothing but a POJO with a HashMap getter/setter.
This will be the object which we will be transferring over the network/application. Since we serialize the object before transferring, this class should implement Serializable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class EmployeeValueObject implements Serializable {
    HashMap employeeSalary = new HashMap();
    public void setSalary (HashMap employeeSalary){
        this.employeeSalary = employeeSalary;
    }

    public HashMap getSalary () {
        return employeeSalary;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the supporting classes which we need and let’s start building the main application.
Let’s call this class EmployeeDetails and this will create an object for the POJO which we created in our previous step and populate with some data.
In addition to that, we will sign the POJO object and then serialize to a file.
In this example we will be also serializing the public key to transfer to the other end.
Note: In production implementations, both these objects shouldn’t be sent at the same time. The application at the other end should already have the public key)&lt;/p&gt;

&lt;p&gt;Let’s create the POJO and populate with some data in the HashMap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;EmployeeValueObject employeeVO = new EmployeeValueObject();
employeeVO.setSalary(populateData());

private static HashMap populateData (){
    HashMap employeeSalary = new HashMap ();
    employeeSalary.put(&#34;3&#34;, &#34;Johns, Galvin D. --&gt; $18,000&#34;);
    employeeSalary.put(&#34;4&#34;, &#34;Weber, Murphy I. --&gt; $5,000&#34;);

    return employeeSalary;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s generate the public and private keys from SecutityUtil and sign the POJO which we created in the above step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;KeyPair keyPair = new SecurityUtil().generateKey();
PrivateKey privateKey = keyPair.getPrivate();
PublicKey publicKey = keyPair.getPublic();

Signature digitalSignature = Signature.getInstance(privateKey.getAlgorithm());
SignedObject digitalSignedObj =
    new SignedObject(employeeVO, privateKey, digitalSignature);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now digitalSignedObj is a digitally signed data with the private key which we generated. Now let’s serialize this object for the secure transfer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;ileOutputStream serializedFileOutput = new FileOutputStream(&#34;employee.ser&#34;);
ObjectOutputStream serializedObjOutput = new ObjectOutputStream(serializedFileOutput);
serializedObjOutput.writeObject(digitalSignedObj);
serializedObjOutput.close();
serializedFileOutput.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will also serialize the public key so that for this example we can send both of them to another machine to verify.
Note: In production implementations, both these objects shouldn’t be sent at the same time. The application at the other end should already have the public key)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;serializedFileOutput = new FileOutputStream(&#34;publickey.ser&#34;);
serializedObjOutput = new ObjectOutputStream(serializedFileOutput);
serializedObjOutput.writeObject(publicKey);
serializedObjOutput.close();
serializedFileOutput.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will complete the creation of application one. When you run this application, it will create two new files in the same directory.
employee.ser – which is the signed and serialized POJO (Salary details) &amp;amp; publickey.ser – public key to verify the POJO.
Now using the appropriate protocol send these files to the other application (remote or local) and let’s start building the verification part.&lt;/p&gt;

&lt;h5 id=&#34;verification-amp-de-serializing-the-java-object&#34;&gt;Verification &amp;amp; De-Serializing the Java Object&lt;/h5&gt;

&lt;p&gt;As a start we have the files employee.ser &amp;amp; publickey.ser. Let’s start building up the class to verify and de-serialize these files.
Let’s name this class DecryptEmployee. The following code should de-serialize the objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;FileInputStream serializedPublicKeyIn = new FileInputStream(&#34;publicKey.ser&#34;);
ObjectInputStream serializedPublicKey = new ObjectInputStream(serializedPublicKeyIn);
PublicKey publicKey = (PublicKey) serializedPublicKey.readObject();

FileInputStream serializedEmployeeIn = new FileInputStream(&#34;employee.ser&#34;);
ObjectInputStream serializedEmployee = new ObjectInputStream(serializedEmployeeIn);
SignedObject digitalSignedObj = (SignedObject) serializedEmployee.readObject();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the public key was not signed, publicKey variable will be readable.
But the employee POJO was signed, so we are reading the object as a SignedObject. Let’s move forward and verify this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Signature digitalSignature = Signature.getInstance(publicKey.getAlgorithm());
boolean decryptFlag = digitalSignedObj.verify(publicKey, digitalSignature);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The decryptFlag contains the status of the verification.
If the public key is incorrect or if the object was tampered, then this will return false and we won’t be able to verify the object.
If its true then everything looks good and we can successfully verify the POJO and print the values from HashMap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;if(decryptFlag) {
    EmployeeValueObject employeeVO = (EmployeeValueObject) digitalSignedObj.getObject();
    HashMap employeeSalary = (HashMap) employeeVO.getSalary();
    Collection collHashMap = employeeSalary.values();
    Iterator collectionIterator = collHashMap.iterator();
    while (collectionIterator.hasNext()) {
        System.out.println(collectionIterator.next());
    }
} else {
    System.out.println (&#34;Decryption Failed. Please check the Keys.&#34;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this application, we will get an output similar to below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00005/signing-java-objects-output.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This can be used in any sensitive application to make sure that the objects which are transferred over the network are safe.&lt;/p&gt;

&lt;p&gt;UPDATE: SignedObject signs the object, but it doesn&amp;rsquo;t encrypt it. So if you need encryption, you can use the Cipher class in Java.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recover from Out of Memory Errors in Java</title>
      <link>https://venishjoe.net/post/recover-from-out-of-memory-errors-in-java/</link>
      <pubDate>Sun, 11 Oct 2009 01:15:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/recover-from-out-of-memory-errors-in-java/</guid>
      <description>&lt;p&gt;In Java, as any other programming language there is a restriction of amount of memory any program can use.
In languages like C the memory is limited to amount of RAM the operating system allocates to the applications or the user space.
Since Java applications are technically running in the Java Virtual Machine (JVM), the applications have memory allocated by the JVM.
Due to that we can start java applications with the amount of memory we need by using the –Xms and –Xmx command line parameters (Given the JVM has the memory to spare).&lt;/p&gt;

&lt;p&gt;In Java, the memory allocation is handled by JVM. We create the objects and JVM decides where to keep those objects in heap.
In languages like C we can use methods like malloc to dynamically allocate memory for objects (variables) and when we are done,
the appropriate clean up methods should be called to release the memory space.
There are advantages in each method, and discussing them will take another separate post.&lt;/p&gt;

&lt;p&gt;In this post, I am going to explain how to recover from the Out of Memory errors. When a Java class faces out of memory errors,
we should try to recover from those errors by reducing or blocking the service rather than crashing the application.
In many cases when the application crashes due to out of memory, JVM is also impacted (which may be running other applications).&lt;/p&gt;

&lt;p&gt;You can ask why can’t we catch the exception.
First of all, catching the exception means that the error has already occurred and in complex systems letting the error happen will be costly.
This method will prevent you from the error itself. When the memory is lower than the defined threshold,
the code is not even executed and we are taking recovery measures to free up some memory. Also if your application is using all the memory allocated to JVM,
when out of memory error occurs it will end up crashing JVM so there is no point catching the exception since your application would have been crashed.&lt;/p&gt;

&lt;p&gt;To recover from the out of memory errors, we need to simulate the error first and then find a solution to recover. So this post consists of two major parts.&lt;/p&gt;

&lt;h5 id=&#34;simulate-out-of-memory-error&#34;&gt;Simulate Out of Memory Error&lt;/h5&gt;

&lt;p&gt;Simulating the error is pretty simple, we will create a lot of array objects in a loop for which JVM will allocate memory spaces. Once the objects reaches a threshold,
the JVM throws out of memory errors. But with the current desktops having at least 1GB of RAM (with at least 100M as the max limit to JVM)
we need to create thousands of objects to simulate the error. So as I mentioned in the start of this post we will use the –Xms and –Xmx options to start the program
with a maximum of 2M so that we can easily simulate the error.&lt;/p&gt;

&lt;p&gt;Create a Java Class with the following code and start with the parameter java -Xms2m –Xmx3m&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public void fillMemory() throws Exception {
    int voidSpace=20;
    for (int outerIterator=1;outerIterator&amp;lt;50;outerIterator++) {
        System.out.println (&#34;Iteration &#34; + outerIterator + &#34; Free Mem: &#34;
            + Runtime.getRuntime().freeMemory());
        int innerIterator=10;
        int[] memoryFillIntVar=new int[voidSpace];
        do {
            memoryFillIntVar[innerIterator]=0;
            innerIterator--;
        } while(innerIterator&amp;gt;0);
        voidSpace = voidSpace * 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this class (MemoryTest.java), you will get an output which will be similar to below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;D:\temp\&gt;java -Xms2m -Xmx3m MemoryTest
Iteration 1 Free Mem: 1826368
Iteration 2 Free Mem: 1826368
Iteration 3 Free Mem: 1826368
Iteration 4 Free Mem: 1818352
Iteration 5 Free Mem: 1738336
Iteration 6 Free Mem: 1100952
Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Java heap space
        at MemoryTest.fillMemory(MemoryTest.java:22)
        at MemoryTest.main(MemoryTest.java:12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have successfully simulated the out of memory error. Let’s continue to the next part where I will show how to recover from these errors.&lt;/p&gt;

&lt;h5 id=&#34;recover-from-the-error&#34;&gt;Recover from the error&lt;/h5&gt;

&lt;p&gt;To recover from the error we will be using one of the utility classes from &lt;a href=&#34;http://db.apache.org/derby/javadoc/engine/overview-summary.html&#34;&gt;Apache Derby V10.6 Internals&lt;/a&gt; called
&lt;a href=&#34;http://db.apache.org/derby/javadoc/engine/org/apache/derby/iapi/services/memory/LowMemory.html&#34;&gt;LowMemory&lt;/a&gt;. The class has the below 2 methods drawing our intrest.&lt;/p&gt;

&lt;p&gt;void setLowMemory() - Sets a low memory watermark where the owner of this object just hit an OutOfMemoryError.&lt;/p&gt;

&lt;p&gt;boolean isLowMemory() - Returns true if a low memory water mark has been set and the current free memory is lower than it.&lt;/p&gt;

&lt;p&gt;So we should use setLowMemory to set a threshold and once set, whenever we call the isLowMemory it will return true/false based on the available memory.
The isLowMemory will allow an low memory watermark to be valid for five seconds after it was set. This stops an incorrect limit being set for ever.
This could occur if other threads were freeing memory when we called Runtime.getRuntime().freeMemory().&lt;/p&gt;

&lt;p&gt;Now let’s rewrite our earlier MemoryTest program to use these methods to recover from the error.
The modification is simple, we just need to encapsulate the object creation in a if condition which checks for the memory before creating the objects.
The modified code is given below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class MemoryTest {
    public static void main(String[] args) throws Exception {
        MemoryTest memoryTest = new MemoryTest ();
        LowMemory lowMemory = new LowMemory();
        long[] memoryFillLongVar = new long[70000];
        lowMemory.setLowMemory();
        memoryTest.fillMemory(lowMemory);
    }
    public void fillMemory(LowMemory lowMemory) throws Exception {
        int voidSpace=20;
        for (int outerIterator=1;outerIterator&amp;lt;50;outerIterator++) {
            System.out.println (&#34;Iteration &#34; + outerIterator + &#34; Free Mem: &#34;
                + Runtime.getRuntime().freeMemory());
            int innerIterator=10;
            if (!lowMemory.isLowMemory()) {
                int[] memoryFillIntVar=new int[voidSpace];
                do {
                    memoryFillIntVar[innerIterator]=0;
                    innerIterator--;
                } while(innerIterator&amp;gt;0);
                    voidSpace = voidSpace * 10;
            } else {
                System.out.println (&#34;Memory lower than threshold to
                    continue. Exiting the loop.&#34;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s run the modified code with the same command line arguments.
The output is given below. Note that the class file for LowMemory.java is present in the same directory as of MemoryTest.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;D:\temp\&gt;java -Xms2m -Xmx3m MemoryTest
Iteration 1 Free Mem: 1349576
Iteration 2 Free Mem: 1349576
Iteration 3 Free Mem: 1349576
Iteration 4 Free Mem: 1341560
Iteration 5 Free Mem: 1261544
Iteration 6 Free Mem: 461528
Memory lower than threshold to continue. Exiting the loop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will be very useful while writing distributed J2EE applications which involves huge databases and processing of a large amount of data within a class.
This will ensure there will be no data corruption and ensure the JVM (which may host multiple applications) is able to recover from the memory errors.
You can always call the GC and runFinalization once this error occurs to free some memory.&lt;/p&gt;

&lt;p&gt;Just as an additional note, in C these kind of errors can be handled as the example code given below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int *pointer = malloc(3 * sizeof(int));
if(pointer == NULL) {
    fprintf(stderr, &#34;Out of memory&#34;);
    exit(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Simple Proxy Server in Java</title>
      <link>https://venishjoe.net/post/simple-proxy-server-in-java/</link>
      <pubDate>Sun, 27 Sep 2009 00:55:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/simple-proxy-server-in-java/</guid>
      <description>&lt;p&gt;In this post, I am going to show how a simple Proxy server can be designed in Java which will provide the core functionalities of a proxy.
From &lt;a href=&#34;http://en.wikipedia.org/wiki/Proxy_server&#34;&gt;Wikipedia&lt;/a&gt;, &amp;ldquo;a proxy server is a server (a computer system or an application program)
that acts as an intermediary for requests from clients seeking resources from other servers.&amp;ldquo;The proxy server generally has some resources,
or has access to some resources and when it receives request from a client, it access the appropriate resource and sends back the response.&lt;/p&gt;

&lt;p&gt;So it serves two purposes, giving access to a resource which the client do not have access and it hides the real client who needs the resource.
The second part is used for the anonymous browsing in Internet using anonymous proxy servers.
Although this may not be as “anonymous” as it sounds because the proxy server which you connect to can maintain logs about the clients who are connecting to the server,
and also the bigger risk being the data theft. Since the “anonymous” proxy server has access to all the request you send,
there is risk of that data being exposed unless there is some kind of encryption in place between the client and the proxy server.&lt;/p&gt;

&lt;p&gt;If you are in a network, and the machine which you are using don’t have access to Internet but another machine in the same subnet has access to Internet, then you can run this
proxy application in the machine which has Internet access and in your local machine, you can configure your web browser to use the IP and Port number of the machine
where the proxy is running in the LAN/Network settings. Once done, you should be able to access the Internet. This is one of the practical use for proxy servers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00003/simple-proxy-server-architecture.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The proxy server which we will be designing will be a simple HTTP proxy which gets web requests based on HTTP protocol and sends back response in the same protocol.
We will start by declaring some constants.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;int proxyServerPortNumber = 7879;
int webServerPortNumber = 80;
String webServerIpAddress = &#34;192.168.1.1&#34;;
final int PROXY_SERVER_TIME_OUT = 5000;
final int SOCKET_TIME_OUT = 2000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proxyServerPortNumber defines the port where the proxy server will be listening. You can use any port number which is not used by other process / standard port.&lt;/p&gt;

&lt;p&gt;webServerIpAddress and webServerPortNumber defines the IP/port where the server can access the resources. Since we are designing this to access websites over http,
the port is defined as 80 and the IP should be a machine which has Internet access (can be localhost too)&lt;/p&gt;

&lt;p&gt;PROXY_SERVER_TIME_OUT and SOCKET_TIME_OUT are standard parameters defined for Server and network socket timeout. You can adjust this based on your needs.&lt;/p&gt;

&lt;p&gt;Now we need to start the Java class to bind to the port number defined and to run in a infinite loop or as a daemon thread, so that it keeps on listening for requests.
In this example, we will be using the infinite loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;try {
    serverSocket = new ServerSocket(proxyServerPortNumber);
} catch(Exception exc) {
        System.exit(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the process will be listening in the port 7879 for requests from clients. Now, let’s open an infinte loop and make a connection to the resource, in our case the web server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;socketProxy = new Socket(InetAddress.getByName(webServerIpAddress),webServerPortNumber);
socketProxy.setSoTimeout(PROXY_SERVER_TIME_OUT);
socket = serverSocket.accept();
socket.setSoTimeout(SOCKET_TIME_OUT);
inputStream = socket.getInputStream();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The request from the client will be received by Input Stream, so once we are connected, we will be sending this Input Stream which is nothing but a normal HTTP REQ object
to the server which has the resource or as in our case the machine connected to Internet. The server will respond with the response which will be a HTTP RES over the
Java Output Stream. We will be forwarding this output stream to the client which will be rendered in the application which the client requested in.
That is if the request was sent through command line, the entire HTML will be printed, if its a browser the page will be rendered.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;try {
    while( (intCounter = in.read()) != -1) {
        if(intCounter == -1) break;
        if(!bREQ)
            bREQ = true;
        pOutputStream.write(intCounter);
        if(byteCheckFl &amp;gt; 0) {
            break;
        }
        if(intCounter == 13 &amp;amp;&amp;amp; intPrevCounter == 10)
            byteCheckFl++;
        intPrevCounter = intCounter;
    }
} catch(Exception e) {
    if(!bREQ) {
        continue;
    }
}

pOutputStream.flush();
pIutputStream = socketProxy.getInputStream();
outputStream = socket.getOutputStream();
try {
    while( (intCounter = pIutputStream.read()) != -1) {
        outputStream.write(intCounter);
    }
} catch(Exception e) {
}
outputStream.flush();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to close all the opened sockets and connections once the response is sent. Since this whole code is running in an infinite loop,
the server will keep on waiting for the requests and sending the responses back. This is a crude implementation of the concept and there is
room for a lot more improvements (like supporting SSL), but this should serve as a foundation to make the proxy a robust one.&lt;/p&gt;

&lt;p&gt;We can easily make this Java class as a Win32 service, so that it will always run in background and starts along with the OS.
That will need some work with JNI. I will explain that in a later post.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recover Database Passwords from Weblogic Server</title>
      <link>https://venishjoe.net/post/recover-database-passwords-from-weblogic-server/</link>
      <pubDate>Sun, 20 Sep 2009 17:24:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/recover-database-passwords-from-weblogic-server/</guid>
      <description>&lt;p&gt;In this post, I am going to explain how to Decrypt or recover the passwords which are encrypted (or hashed) in Weblogic 8.1 especially the database passwords.
If you ever forgot the database password which is already configured with Weblogic or the password for the user which is used to start Weblogic, this will be handy.
The hashed passwords can be normally found in config.xml and boot.properties inside the application domain.
The database passwords will be in config.xml under the JDBC configuration and will look something like below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PasswordEncrypted=&amp;quot;{3DES}bDcllidskanDsaIsnaiG==&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To recover the passwords, we need some prerequisites which are listed below.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;weblogic.jar &amp;amp; jsafeFIPS.jar from the Weblogic server. (You can find this under WL_HOME/server/lib directory)&lt;/li&gt;
&lt;li&gt;SerializedSystemIni.dat from the application domain (You can find this under the application domain root)&lt;/li&gt;
&lt;li&gt;The encrypted password from config.xml / boot.properties including {3DES}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SerializedSystemIni.dat has the key to recover the passwords so this is absolutely essential and it should be from the same server since the key depends on the machine.
If you are not able to find this file, then probably the server administrator hasn’t given read access to this file to all the users. For Production systems that should be a practice,
only the id which will be starting the weblogic server should have read permissions to the SerializedSystemIni.dat file. If not, this will be a security risk,
its like leaving the key for your Home on the street. Coming back to the subject, if you got the file then you are all set for the next step.&lt;/p&gt;

&lt;p&gt;Assuming you have all the files needed, let’s proceed to the next step. You can copy all the prerequisite files to your workstation or if needed you can run the utility from the server too.
As long as the machines have JDK installed it should be fine.&lt;/p&gt;

&lt;p&gt;To recover the passwords we will be using a utility from Apache &lt;a href=&#34;http://geronimo.apache.org/apidocs/2.0.1/&#34;&gt;Geronimo 2.0.1 API&lt;/a&gt; -
&lt;a href=&#34;http://geronimo.apache.org/apidocs/2.0.1/src-html/org/apache/geronimo/converter/bea/Weblogic81Utils.html&#34;&gt;Weblogic81Utils.java&lt;/a&gt;. Although this file is a part of a package,
this can be run as a standalone class with little modification. All you need to do is to remove the package reference and add a main() method to the class.
The code for main() method is below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static void main(String args[]) {
    try{
        String beaDir = &#34;$Server/lib or the Directory which has the requried JAR files$&#34;;
        String appDir = &#34;$App Domain or the Directory which has SerializedSystemIni.dat$&#34;;
        String hashedPassword = &#34;{3DES}Vdsds76nGsfdsfKJbg54ss==&#34;;
        Weblogic81Utils weblogic81Utils = new Weblogic81Utils(beaDir, appDir);
        String plainTextPassword = weblogic81Utils.decryptString(hashedPassword);
        String configXML = weblogic81Utils.getConfigXML();
        Properties bootProperties = (Properties) weblogic81Utils.getBootProperties();
        System.out.println(&#34;-----------------------------------------------------&#34;);
        System.out.println(&#34;hashedPassword&#34; + &#34; == &#34; + plainTextPassword);
        System.out.println(&#34;boot.properties&#34; + &#34; &amp;lt;username&amp;gt; &#34;
            + bootProperties.getProperty(&#34;username&#34;));
        System.out.println(&#34;boot.properties&#34; + &#34; &amp;lt;password&amp;gt; &#34;
            + bootProperties.getProperty(&#34;password&#34;));
        System.out.println(&#34;-----------------------------------------------------&#34;);
    } catch (Exception e) {
        throw (RuntimeException)new IllegalArgumentException(&#34;Unable to initialize&#34;
            + &#34;encryption routines from provided arguments&#34;).initCause(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beaDir - If you are running this on the server, it will be the $WL_HOME/server/lib directory. If you are running elsewhere it will be the path which has weblogic.jar and jsafeFIPS.jar.&lt;/p&gt;

&lt;p&gt;appDir - If you are running this on the server, it will be your application domain directory. If you are running elsewhere, it will be the path which contains SerializedSystemIni.dat,
config.xml and boot.properties.&lt;/p&gt;

&lt;p&gt;hashedPassword – In this example, I am not reading config.xml directly instead I give the encrypted password as a input. So this will be the encrypted database password from your config.xml.&lt;/p&gt;

&lt;p&gt;Save the class file and we are all set to run the program. Make sure you removed the package reference since we are running this as a standalone program. No other change is required.
Compile the class and run the class. I tested this using JDK 1.6, but any JDK higher than 1.4 should work.&lt;/p&gt;

&lt;p&gt;Sample output is given below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00002/recover-database-passwords-output.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This was tested with Weblogic Server 8.1 and JDK 1.6.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Serial Key Generation and Validation in Java</title>
      <link>https://venishjoe.net/post/serial-key-generation-and-validation-in-java/</link>
      <pubDate>Mon, 31 Aug 2009 23:54:00 +0000</pubDate>
      <author>venish@venishjoe.net (Venish Joe Clarence)</author>
      <guid>https://venishjoe.net/post/serial-key-generation-and-validation-in-java/</guid>
      <description>&lt;p&gt;In this post, I am going to show how to write a very basic serial key generation module for any Java based application - Same algorithms can be used for any programming language. The module consists of three parts.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;font color=&#34;red&#34;&gt;WARNING:&lt;/font&gt;&lt;/b&gt; Hash functions used in this article are obsolete and extremely vulnerable to attacks. For real-world implementations, select a more secure hash algorithm.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Algorithm for Serial Generation&lt;/li&gt;
&lt;li&gt;Generating the Serial&lt;/li&gt;
&lt;li&gt;Validating the Serial&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;algorithm-for-serial-generation&#34;&gt;Algorithm for Serial Generation&lt;/h5&gt;

&lt;p&gt;The following can be used as a simple algorithm for generating serial keys with 18 digits. In this method we are generating the serials based on the input the user gives, which can be the name of the user,
company name etc. So most of the times the serial will be unique (based on the input). We get the name of the user as the input and generate the MD2, MD5 &amp;amp; SHA1 hashes for the string and concatenate together.
This will generate a total of 104 digits, since we need only 18 of them, we can use a set of pre defined numbers to select the 18 digits.&lt;/p&gt;

&lt;p&gt;The below figure explains the algorithm. I have selected some random numbers to pick the 18 digits from 104 character hash, you can use any number you like which makes the serial unique.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00001/serial-key-generation-algorithm.png#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;generating-the-serial&#34;&gt;Generating the Serial&lt;/h5&gt;

&lt;p&gt;To generate the serial, we need a input string and based on the input string we will be generating MD2, MD5 and SHA1 hashes. The method calculateSecurityHash takes the input string and the hashing method
as input and generates the hash based on the method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String serialNumberEncoded = calculateSecurityHash(fullNameString,&#34;MD2&#34;) +
    calculateSecurityHash(fullNameString,&#34;MD5&#34;) +
        calculateSecurityHash(fullNameString,&#34;SHA1&#34;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generating the Hash for the input string based on the type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;private String calculateSecurityHash(String stringInput, String algorithmName)
    throws java.security.NoSuchAlgorithmException {
        String hexMessageEncode = &#34;&#34;;
        byte[] buffer = stringInput.getBytes();
        java.security.MessageDigest messageDigest =
            java.security.MessageDigest.getInstance(algorithmName);
        messageDigest.update(buffer);
        byte[] messageDigestBytes = messageDigest.digest();
        for (int index=0; index &amp;lt; messageDigestBytes.length ; index ++) {
            int countEncode = messageDigestBytes[index] &amp;amp; 0xff;
            if (Integer.toHexString(countEncode).length() == 1)
                hexMessageEncode = hexMessageEncode + &#34;0&#34;;
            hexMessageEncode = hexMessageEncode + Integer.toHexString(countEncode);
        }
        return hexMessageEncode;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once all the three types of hashes are combined, we will have a total of 104 characters. Since we need only 18 for our serial key we can pick any random 18 digits from the combined hash.
We cannot use random number generation to pick up the 18 digits since we need a valid exit strategy for validating the key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String serialNumber = &#34;&#34;
    + serialNumberEncoded.charAt(32)  + serialNumberEncoded.charAt(76)
    + serialNumberEncoded.charAt(100) + serialNumberEncoded.charAt(50) + &#34;-&#34;
    + serialNumberEncoded.charAt(2)   + serialNumberEncoded.charAt(91)
    + serialNumberEncoded.charAt(73)  + serialNumberEncoded.charAt(72)
    + serialNumberEncoded.charAt(98)  + &#34;-&#34;
    + serialNumberEncoded.charAt(47)  + serialNumberEncoded.charAt(65)
    + serialNumberEncoded.charAt(18)  + serialNumberEncoded.charAt(85) + &#34;-&#34;
    + serialNumberEncoded.charAt(27)  + serialNumberEncoded.charAt(53)
    + serialNumberEncoded.charAt(102) + serialNumberEncoded.charAt(15)
    + serialNumberEncoded.charAt(99);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can replace the numbers with anything between 0 and 103 so that the key is unique and based on the input string.&lt;/p&gt;

&lt;h5 id=&#34;validating-the-serial&#34;&gt;Validating the Serial&lt;/h5&gt;

&lt;p&gt;Now, whenever we get a user name and serial combination, we should be able to validate that. Since we already know the algorithm used to generate the serial, the validation part is pretty easier.
We cannot follow the steps which we did while generating the serial in opposite direction because we will end up with a bunch of characters without any valid lead.
Since we have the serial and user name to validate, we take the user name and generate the serial for the user name as per our algorithm. Once we have the serial number,
we compare this against the serial which we got for validation, if both matches then we have a valid key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String serialNumberEncoded =
    registrationAppSerialGenerationReversal.calculateSecurityHash(fullNameString,&#34;MD2&#34;)
    + registrationAppSerialGenerationReversal.calculateSecurityHash(fullNameString,&#34;MD5&#34;)
    + registrationAppSerialGenerationReversal.calculateSecurityHash(fullNameString,&#34;SHA1&#34;);

String serialNumberCalc = &#34;&#34;
    + serialNumberEncoded.charAt(32)  + serialNumberEncoded.charAt(76)
    + serialNumberEncoded.charAt(100) + serialNumberEncoded.charAt(50) + &#34;-&#34;
    + serialNumberEncoded.charAt(2)   + serialNumberEncoded.charAt(91)
    + serialNumberEncoded.charAt(73)  + serialNumberEncoded.charAt(72)
    + serialNumberEncoded.charAt(98)  + &#34;-&#34; + serialNumberEncoded.charAt(47)
    + serialNumberEncoded.charAt(65)  + serialNumberEncoded.charAt(18)
    + serialNumberEncoded.charAt(85)  + &#34;-&#34; + serialNumberEncoded.charAt(27)
    + serialNumberEncoded.charAt(53)  + serialNumberEncoded.charAt(102)
    + serialNumberEncoded.charAt(15)  + serialNumberEncoded.charAt(99);

if (serialNumber.equals(serialNumberCalc))
    System.out.println(&#34;Serial MATCH&#34;);
else
    System.out.println(&#34;Serial MIS-MATCH&#34;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample output from this program is demonstrated below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://venishjoe.net/media/images/00001/serial-key-generation-output.jpg#floatcenter&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>